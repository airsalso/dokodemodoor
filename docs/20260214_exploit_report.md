# 20260214 Prompt Flow & Exploit 심층 분석 보고서

작성일: 2026-02-14  
분석 기준 시점: 2026-02-13 코드베이스(`prompts-openai/`, `src/`, `mcp-server/src/`)

## 1. 전체 프롬프트 흐름 및 정렬 분석

### 1.1 실제 실행 파이프라인(코드 기준)
현재 파이프라인의 공식 순서는 다음과 같다.

1. `pre-reconnaissance`
2. `reconnaissance` (`login-check` -> `recon` -> `recon-verify`)
3. `api-fuzzing`
4. `vulnerability-analysis` (8개)
5. `exploitation` (8개)
6. `reporting`

근거:
- `src/session-manager.js:268`
- `src/session-manager.js:276`
- `src/session-manager.js:271`
- `src/session-manager.js:272`

### 1.2 병렬/직렬 실행 정렬
- `vulnerability-analysis`는 병렬 실행: `src/checkpoint-manager.js:1293`
- `exploitation`도 병렬 실행: `src/checkpoint-manager.js:1308`
- `reconnaissance`, `reporting`은 순차 실행: `src/checkpoint-manager.js:1355`

즉, 단계 순서 자체는 엄격하지만, `vuln 8개`와 `exploit 8개` 내부는 동시 수행된다.

### 1.3 프롬프트 매핑 정렬
에이전트 -> 프롬프트 매핑은 명확하다.

- `sqli-vuln -> vuln-sqli`, `sqli-exploit -> exploit-sqli` 형태 1:1 대칭
- 8개 카테고리 모두 `vuln`과 `exploit` 파일이 페어로 존재

근거:
- `src/checkpoint-manager.js:1824`
- `src/checkpoint-manager.js:1837`

### 1.4 exploit 단계 진입 게이트 정렬
`exploit`은 무조건 실행되지 않는다. 아래 조건을 만족해야만 해당 exploit agent가 활성화된다.

- 대응 `-vuln` agent 완료
- queue + analysis deliverable 유효
- queue 내 `vulnerabilities.length > 0`

근거:
- `src/checkpoint-manager.js:994`
- `src/checkpoint-manager.js:1018`
- `src/queue-validation.js:364`

요약하면, **흐름 정렬(phase ordering) 자체는 구조적으로 안정적**이다.

## 2. 단계 간 산출물 계약(Contract) 정렬

### 2.1 계약 체인
- `pre-recon` -> `pre_recon_deliverable.md`
- `recon` -> `recon_deliverable.md`
- `recon-verify` -> `recon_verify_deliverable.md`
- `api-fuzzer` -> `api_fuzzer_deliverable.md`
- `vuln-*` -> `*_analysis_deliverable.md` + `*_exploitation_queue.json`
- `exploit-*` -> `*_exploitation_evidence.json`
- `report` -> `comprehensive_security_assessment_report.md`

근거:
- `mcp-server/src/types/deliverables.js:106`
- `mcp-server/src/types/deliverables.js:110`
- `mcp-server/src/types/deliverables.js:125`
- `mcp-server/src/types/deliverables.js:133`

### 2.2 report 단계와의 정렬
report는 `_report_inputs` 축약본을 읽도록 설계되어 있고, exploit evidence/queue도 인덱스용으로 포함된다.

근거:
- `src/phases/reporting.js:173`
- `src/phases/reporting.js:190`
- `prompts-openai/report-executive.txt:34`

정렬성 평가는 양호하나, 아래 5장의 `exploit` 규약 충돌이 누적되면 report 신뢰도도 함께 저하된다.

## 3. Exploit 8개 프롬프트 심층 분석

### 3.1 공통 구조 분석
8개 exploit 프롬프트는 공통적으로 다음 뼈대를 공유한다.

- Queue 중심 실행(`deliverables/*_exploitation_queue.json`)
- Intelligence 선독(`pre_recon`, `recon`, `recon_verify`, `*_analysis_deliverable`)
- `TodoWrite` 기반 단일 취약점 단위 진행
- `save_deliverable`로 `*_EVIDENCE` 저장
- `_exploit-scope`, `_evidence-format`, `_exploit-stagnation-rules` 재사용

근거:
- `prompts-openai/exploit-sqli.txt:11`
- `prompts-openai/exploit-auth.txt:138`
- `prompts-openai/exploit-authz.txt:126`
- `prompts-openai/shared/_exploit-scope.txt:1`
- `prompts-openai/shared/_evidence-format.txt:1`

### 3.2 카테고리별 강점/리스크

#### 1) `exploit-sqli.txt` (262 lines)
강점:
- DB 타입/단계별(확인 -> 열거 -> 유출) 실행 플로우가 명확
- SQLi 성공 레벨 정의가 비교적 실무적

리스크:
- 일부 분류 용어(POTENTIAL 중심)가 공통 evidence enum과 충돌 가능

근거: `prompts-openai/exploit-sqli.txt:204`, `prompts-openai/exploit-sqli.txt:237`

#### 2) `exploit-codei.txt` (237 lines)
강점:
- sink 중심 증명(`id`, `whoami`) 기준이 명확
- deserialization/OOB 고려 포함

리스크:
- 긴급 무결성 규칙(예: 금지 verdict, 빈 evidence 처리)이 auth/xss 계열 대비 약함

근거: `prompts-openai/exploit-codei.txt:53`, `prompts-openai/exploit-codei.txt:203`

#### 3) `exploit-ssti.txt` (223 lines)
강점:
- 저장형 입력(write) + 렌더 트리거(render) 강제는 매우 우수
- 500 에러 피드백 기반 payload refinement 지시가 실전적

리스크:
- 분류 체계가 공통 enum과 완전히 동기화되어 있지 않음

근거: `prompts-openai/exploit-ssti.txt:99`, `prompts-openai/exploit-ssti.txt:187`

#### 4) `exploit-pathi.txt` (209 lines)
강점:
- OS별 경로/인코딩 우회/로그 포이즈닝까지 포함

리스크:
- 레벨 정의와 최종 verdict 지침의 일관성이 다소 약함

근거: `prompts-openai/exploit-pathi.txt:162`, `prompts-openai/exploit-pathi.txt:187`

#### 5) `exploit-xss.txt` (412 lines)
강점:
- source-path-sink 그래프 기반 전략이 고도화됨
- reflection != execution 원칙이 정확함

리스크:
- `NOT VULNERABLE`, `FALSE POSITIVE` 분류를 적극 지시하여 저장 스키마 충돌 가능성 큼
- 템플릿형 문구가 길고 중복되어 토큰 소모가 큼

근거: `prompts-openai/exploit-xss.txt:62`, `prompts-openai/exploit-xss.txt:335`

#### 6) `exploit-auth.txt` (417 lines)
강점:
- 하드코딩 금지, 실제 키/시크릿 추출 요구가 매우 좋음
- 인증 세션 재사용 및 무결성 원칙이 강함

리스크:
- `ATTEMPTED - FAILED` 분류를 지시하지만 evidence validator 허용값에 없음
- “빈 evidence 금지”와 “queue empty면 빈 배열 저장” 지시가 병존

근거: `prompts-openai/exploit-auth.txt:45`, `prompts-openai/exploit-auth.txt:136`, `prompts-openai/exploit-auth.txt:394`

#### 7) `exploit-ssrf.txt` (479 lines)
강점:
- SSRF 타입별(클래식/블라인드/세미블라인드/저장형) 검증 프레임은 매우 우수
- 내부망 접근 증거 기준이 구체적

리스크:
- `ATTEMPTED - FAILED`, `FALSE POSITIVE` 분류 유도 문제 동일
- 예시가 길고 정책 외 OOB 서비스 언급이 포함되어 운영 정책 이탈 가능성

근거: `prompts-openai/exploit-ssrf.txt:55`, `prompts-openai/exploit-ssrf.txt:378`

#### 8) `exploit-authz.txt` (429 lines)
강점:
- 2-principal 테스트 강제는 AuthZ 실효성 검증에 매우 적합
- Horizontal/Vertical/Workflow 분기 지시가 명확

리스크:
- `ATTEMPTED - FAILED`, `FALSE POSITIVE` 분류 충돌 동일
- “two final files” 문구 잔존(실제는 evidence 1개 저장)

근거: `prompts-openai/exploit-authz.txt:45`, `prompts-openai/exploit-authz.txt:399`

## 4. Exploit 8개 교차 이슈(핵심)

### [Critical-1] Verdict 체계 충돌로 저장 실패 유발 가능
문제:
- 공통 scope는 `OUT_OF_SCOPE_INTERNAL`, `FALSE_POSITIVE`를 verdict로 제시
- 일부 exploit는 `ATTEMPTED - FAILED`, `NOT VULNERABLE`까지 사용
- 그러나 evidence validator는 `EXPLOITED`, `BLOCKED_BY_SECURITY`, `POTENTIAL`만 허용

근거:
- `prompts-openai/shared/_exploit-scope.txt:17`
- `prompts-openai/shared/_evidence-format.txt:7`
- `mcp-server/src/validation/evidence-validator.js:190`
- `prompts-openai/exploit-auth.txt:45`
- `prompts-openai/exploit-xss.txt:62`

영향:
- `save_deliverable` validation 실패 -> exploit 단계 재시도/루프/중단 가능

### [Critical-2] queue merge dedup 키와 vuln queue 스키마 불일치
문제:
- queue merge dedup 키가 `vulnerability_type + source`로 고정
- auth/authz/ssrf queue 스키마에는 `source`가 없고 `source_endpoint`/`endpoint`를 사용

근거:
- `mcp-server/src/tools/save-deliverable.js:121`
- `prompts-openai/vuln-auth.txt:352`
- `prompts-openai/vuln-authz.txt:348`
- `prompts-openai/vuln-ssrf.txt:316`

영향:
- 중복 제거 시 서로 다른 취약점이 같은 키로 충돌하여 queue 누락 가능
- exploit 대상 누락 -> 최종 보고서 과소 보고 위험

### [High-3] 병렬 exploit + Playwright server 공유로 증거 오염 가능
문제:
- exploit 단계는 병렬 실행
- `sqli/codei/ssti/pathi` 4개 exploit이 모두 `playwright-agent1` 공유

근거:
- `src/checkpoint-manager.js:1058`
- `src/constants.js:117`
- `src/constants.js:120`

영향:
- 세션/쿠키/스크린샷/네트워크 로그가 교차 오염될 수 있음
- 재현성 저하 및 category 간 증거 혼선

### [High-4] 빈 evidence 처리 지시와 validator 규칙 충돌
문제:
- 여러 exploit 프롬프트가 queue empty 시 `{ "vulnerabilities": [] }` 저장 지시
- validator는 빈 배열을 invalid로 처리

근거:
- `prompts-openai/exploit-auth.txt:136`
- `prompts-openai/exploit-xss.txt:122`
- `mcp-server/src/validation/evidence-validator.js:163`

영향:
- 수동 실행/예외 경로에서 저장 실패

### [Medium-5] 결과 집계 로직이 BLOCKED_BY_SECURITY를 “No Vulns”로 축소
문제:
- exploit 결과 집계는 `EXPLOITED`, `POTENTIAL`만 별도 집계
- `BLOCKED_BY_SECURITY`는 별도 카운트가 없어 “No Vulns”로 보일 수 있음

근거:
- `src/checkpoint-manager.js:1175`
- `src/checkpoint-manager.js:1199`

영향:
- 운영 대시보드/요약에서 방어 성공 이벤트가 누락되어 잘못된 해석 가능

### [Medium-6] 도구 명칭 불일치(프롬프트-런타임)
문제:
- pre-recon은 `write_to_file` 요구(도구 없음)
- api-fuzzer는 `TodoRead` 언급(도구 없음)
- 일부 프롬프트는 `browse_file` 미존재라고 설명하지만 런타임에 alias로 존재

근거:
- `prompts-openai/pre-recon-code.txt:171`
- `prompts-openai/api-fuzzer.txt:48`
- `src/ai/tools/tool-registry.js:210`

영향:
- 초기 턴 낭비, 잘못된 도구 호출, 불필요한 에러 루프

## 5. 정렬 총평

### 5.1 구조적 완성도
- 단계 순서, 선행조건, 산출물 체인은 잘 정렬됨
- vuln -> exploit 1:1 페어링도 명확함

### 5.2 실무 리스크
- exploit 8개는 품질이 높지만, **공통 verdict/evidence 규약 불일치**가 가장 큰 실패 요인
- 특히 auth/xss/ssrf/authz의 장문 템플릿 계열에서 충돌 지시가 많이 발생

## 6. 개선 권고안 (우선순위)

### P0 (즉시)
1. verdict 단일 표준화
- 전체 exploit + shared 문구를 `EXPLOITED | BLOCKED_BY_SECURITY | POTENTIAL`만 사용하도록 통일
- `FALSE_POSITIVE`, `ATTEMPTED - FAILED`, `NOT VULNERABLE`, `OUT_OF_SCOPE_INTERNAL`는 내부 reasoning 용어로만 제한

2. queue merge dedup 키 수정
- `source` 단일 키 대신 카테고리별 fallback 포함
- 예: `source || source_endpoint || endpoint || vulnerable_code_location || ID`

3. exploit 병렬 Playwright 충돌 완화
- 최소한 `sqli/codei/ssti/pathi`를 서로 다른 Playwright 서버로 분리하거나, 해당 4개는 Playwright 비의존 모드로 명시

### P1 (단기)
1. exploit 공통 템플릿 리팩토링
- `_exploit-shared-core.txt` 신설 후, completion/verdict/evidence 규칙을 단일 include로 관리

2. 빈 queue 처리 규칙 정렬
- validator를 empty 허용으로 바꾸거나, 프롬프트에서 “queue empty면 저장 시도 금지/스킵”으로 수정

3. “two final files” 문구 제거
- 실제 저장 대상이 1개 evidence 파일이므로 문구 정합성 확보

### P2 (중기)
1. prompt lint 도입
- 금지 verdict, 미등록 도구명, 중복 completion 문구를 CI에서 검사

2. exploit 결과 집계 개선
- `BLOCKED_BY_SECURITY` 별도 카운트/표시 추가

## 7. 결론
현재 프롬프트 체계는 파이프라인 정렬과 역할 분담 자체는 잘 구성되어 있다. 다만 exploit 8개는 고도화된 전략을 담고 있음에도 불구하고, **공통 스키마/validator와 충돌하는 분류 지시**가 잦아 실운영 실패 가능성이 높다. 우선순위는 명확하다: **(1) verdict 표준화, (2) queue merge 키 정합화, (3) 병렬 Playwright 충돌 제거**를 먼저 해결해야 한다.

## 8. 개선 적용 현황 (2026-02-14)

### 적용 완료
- P0-1 verdict 단일 표준화: exploit 프롬프트/공통 include에서 `EXPLOITED | BLOCKED_BY_SECURITY | POTENTIAL`만 사용하도록 정리. (`prompts-openai/exploit-*.txt`, `prompts-openai/shared/_exploit-scope.txt`)
- P0-2 queue merge dedup 키 수정: `source` 단일 키 의존을 제거하고 다중 fallback + 파라미터/role 기반 키를 추가. (`mcp-server/src/tools/save-deliverable.js`)
- P0-3 Playwright 충돌 완화: vuln/exploit 병렬 실행 시 카테고리별 Playwright 인스턴스 분산 매핑 적용. (`src/constants.js`)
- P1-1 exploit 공통 템플릿 리팩토링: `_exploit-shared-core.txt` 신설 후 exploit 8개 프롬프트에 include로 주입. (`prompts-openai/shared/_exploit-shared-core.txt`, `prompts-openai/exploit-*.txt`)
- P1-2 빈 queue 처리 규칙 정렬: evidence validator에서 `{"vulnerabilities":[]}` 허용. (`mcp-server/src/validation/evidence-validator.js`)
- P1-3 “two final files” 문구 제거: exploit 프롬프트에서 단일 evidence 산출물 계약으로 정리. (`prompts-openai/exploit-*.txt`)
- P2-1 prompt lint 도입: 금지 문구/미등록 도구명/완료 문구 회귀를 검사하는 `prompt-lint` 스크립트 추가. (`scripts/prompt-lint.mjs`, `package.json`)
- P2-2 exploit 결과 집계 개선: `BLOCKED_BY_SECURITY` 결과를 별도 카운트/표시. (`src/checkpoint-manager.js`)
